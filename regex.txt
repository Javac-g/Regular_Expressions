Regex fragment	What it matches	Example matches (strings)
.	Any single character except newline (by default)	a, 7, !
.*	Any number of characters (can be empty)	"" (empty), hello, abc123
.+	One or more characters	a, hello, ---
.*?	Any number of characters, minimal (lazy)	"", a, hello
.+?	One or more characters, minimal (lazy)	a, he, x
[\s\S]*	Absolutely anything (including newlines)	hello, line1\nline2, ""
[^\n]*	Anything except newline	hello, abc123, ""
\s*	Optional whitespace	"", " ", "\t\t"
\s+	One or more whitespace	" ", " ", "\t "
\S+	One or more non-whitespace “token”	hello, abc123, x_y
\d	One digit	0, 7
\d+	One or more digits	7, 12345
\d*	Zero or more digits	"", 0, 123
\d{2}	Exactly 2 digits	07, 42
\d{1,3}	1 to 3 digits	7, 42, 999
[0-9]+	Digits (explicit ASCII)	123, 007
[1-9]\d*	Positive integer without leading zero	1, 42, 9000
`0	[1-9]\d*`	Non-negative integer, no leading zeros (except 0)
\w	“Word” char (letter/digit/underscore)	a, Z, 7, _
\w+	Word token	hello, a_b2, _x
\w*	Optional word token	"", x, abc_1
[A-Za-z]+	Letters only (ASCII)	Hello, abc
[A-Za-z]*	Optional letters only	"", Abc
[A-Z][a-z]*	Capitalized word (simple)	John, Paris
\p{L}+	Unicode letters (best for i18n names)	Андрій, Maksym, 山田
\p{N}+	Unicode digits/number chars	123, １２３
\p{Lu}\p{Ll}+	Uppercase then lowercase letters (Unicode)	John, Émile
\p{L}[\p{L}\p{N}_]*	Identifier-like (unicode letter start)	Имя1, Name_2
^	Start of string/line (depending on mode)	Matches position before hello in hello
$	End of string/line (depending on mode)	Matches position after hello in hello
^\d+$	Entire string is digits	0, 12345
^\s*$	Empty or whitespace-only line	"", " "
\b\w+\b	Whole “word” token (word boundaries)	hello, abc_1 (as a word)
\B\w+\B	Word chars not at boundaries (inside a word)	In hello, matches ell (conceptually)
(...)	Capturing group	Captures part like abc inside a larger match
(?:...)	Non-capturing group	Groups without creating a capture
(?<name>...)	Named capture group	Captures a part labeled name
(\w)(\w*)	First char + rest (word)	a → a + ""; test → t + est
(\d)(\d*)	First digit + remaining digits	7 → 7 + ""; 123 → 1 + 23
(.)(.*)	First char + rest (anything except newline for .)	A → A+""; Hi! → H+i!
(\S+)\s+(\S+)	Two tokens separated by whitespace	hello world, foo\tbar
^(\S.*\S)$	Trimmed non-empty line (no outer spaces)	hello, a b (not " hello ")
([^,]+)	One “CSV cell” without commas	apple, hello world
(\w+)(?:-\w+)*	Hyphen-joined words	a-b, foo-bar-baz
(\w+)(?:,\w+)*	Comma-separated words	a,b,c, one,two
(\d+)(?:\.\d+)*	Dot-separated numeric segments	1.2, 10.0.7
(?:\w+\.)+\w+	Dot-separated words (domain-ish)	example.com, a.b.c
"([^"]*)"	Double-quoted content (no inner ")	"hello", ""
'([^']*)'	Single-quoted content	'abc', ''
`([^`]*)`	Backtick-quoted content	`test`, ``
(\w+)=([^\s]+)	Key=value (value is one token)	a=1, mode=fast
([^=]+)=([^&]+)	Query-style key=value (until &)	q=hello, lang=en
(\w+):(.+)	key: value (value is rest of line)	Name: John, Note: hello world
(?=...)	Positive lookahead (next must match)	In abc123, abc before 123
(?!...)	Negative lookahead (next must NOT match)	foo not followed by bar
(?<=...)	Positive lookbehind (prev must match)	Digits preceded by $ in $123
(?<!...)	Negative lookbehind (prev must NOT match)	cat not preceded by wild
\.	Literal dot	.
\+	Literal plus	+
\?	Literal question mark	?
|	Literal pipe	`
\\	Literal backslash	\
\[	Literal [	[
\]	Literal ]	]
\(	Literal (	(
\)	Literal )	)
(?>...)	Atomic group (no backtracking inside)	Used to prevent slow fallback matches
\d++	Possessive digits (no backtracking)	Matches 123 as one locked chunk
[^/]*+	Possessive “no slash” run	abc, folder (until a /)
(\w)\1*	Same char repeated (run-length)	aaaa, ___, 777
(\d+)(\.\d+)?	Integer with optional decimal	10, 10.5
([A-Za-z_])([A-Za-z0-9_]*)	Identifier: start + rest	x, _tmp, var123
([^/]+)/([^/]+)	Two path segments	users/123, img/logo
(?:/[^/]+)+	One or more /segment parts	/a, /a/b/c
